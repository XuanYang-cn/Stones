# TCP and UDP DETAILS

## TCP DETAILS
### TCP 协议简介

TCP （Transport Control Protocal, 传输控制协议） 工作在网络的 OSI 七层模型中的第四层，传输层，第四层的数据叫段（Segment）。 TCP 协议的主要特性就是面向字节流，传输可靠，面向连接。

### TCP 协议的报头

![tcp header](../pictures/tcp_header.jpg)

**16bit 源端口号/16bit 目的端口号**： 用于区别主机中的不同进程，而 IP 地址是用来区分不同主机的，源端口号和目的端口号加上 IP 首部中的源 IP 地址和目的 IP 地址就能唯一的确定一个 TCP 连接

**32bit 序号 Sequence Number**： 用来标识发送端发送的数据字节流，主要用来解决网络包乱序的问题

**32bit 确认序号 Acknowledgment Number**： 表示接收方期望收到发送方下一个报文段的第一个字节数据的编号

**4bit 首部 + 保留 6bit + 6bit 标志位 Flags + 16bit 窗口 Window size**
- **首部 Offset**： 任选字段的长度，最多能表示 15 个 32bit的字，即4*15=60个字节的首部长度， 因此TCP最多有 60 字节的首部，当没有任选字段时，正常长度是 20 字节

- **标志位 Flags**： 六个标识位，多个可以同时被设置为 1，主要用来操控 TCP 状态

|FLAGS | MEANING|
|:----:|:---|
|URG|表示 TCP 包的紧急指针域有效，用来保证 TCP 连接不被中断，并且监督中间层设备要尽快处理这些数据|
|**ACK**|为 1 时表示应答域（Acknowledgement Number）有效|
|PSH|表示 Push 操作，也就是在数据包到达接收端之后，立即传送给应用程序，而不是在缓冲区中排队|
|RST|表示连接复位请求，用来复位那些产生错误的连接，也被用来拒绝错误和非法的数据包|
|**SYN**|表示同步序号，用来建立连接。SYN 和 ACK标识搭配使用，当第一次请求连接时 SYN = 1， ACK = 0， 当连接被响应时 SYN = 1， ACK = 1|
|**FIN**|表示发送端已经达到数据末尾，双方的数据传送完成。 发送 FIN 标识为的 TCP 数据包之后，连接即将被断开|

- **窗口 Window**：窗口大小，也就是滑动窗口，用来进行流量控制

### TCP 连接管理

#### 1. TCP 三次握手

![](../pictures/TCP三次握手.png)

整个流程：

1. 客户端主动打开，发送连接请求报文段，其中 SYN=1, Sequence = x, 然后进入 **SYN_SEND** 状态

2. 服务器收到 SYN 报文段后，给客户端发送确认，其中 SYN=1， Sequence=y, ACK=1, Acknowledgment number = x+1, 然后进入 **SYN_RECV** 的状态，这个状态被称为半连接状态

3. 客户端收到服务器的返回后再次想服务器发送报文， 其中 ACK=1，Sequence = x+1， Acknowledgment number = y+1，此时客户端进入 **ESTABLISHED**。 服务端收到这个回复的报文后，也进入 **ESTABLISHED** 状态。

至此，三次握手过程就完成了。

**Q1.** 为什么是三次握手，为什么不是两次握手？或者四次握手？

A1. 主要是为了防止已经失效的连接请求报文（在某些网络节点长时间滞留）又传回到服务器而产生无效的连接（因为此时客户端并没有连接请求，但是服务端以为客户端有连接请求，服务器会一直等待不存在的客户端给它发数据，会造成服务器的资源浪费）

**Q2.** 什么是 SYN 攻击？

A2. 在三次握手过程中，当 Server 发送 SYN、ACK 之后，收到 Client 的 ACK 之前的连接状态称作半连接状态（half-open connect），也就是 SYN_RCVD 状态。 SYN 攻击就是 Client 在短时间内伪造大量不存在的 IP 地址，并且不断向 Server 发送请求连接，Server 回复并等待 Client 确认。由于源地址不存在，因此 Server 会不断的重发直至超时，这些伪造的 SYN 包会长时间占用未连接队列，导致正常的 SYN 请求应为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。

SYN 攻击是典型的 **DDOS** 攻击，检测 SYN 攻击的方式很简单，当 Server 上有大量半连接状态且源 IP 地址是随机的就可以断定遭受到了 SYN 攻击，可以用下面的命令

    $netstat -na | grep SYN_RECV

#### 2. TCP 四次挥手

TCP四次挥手是 TCP 连接释放的过程，流程图如下

![](../pictures/TCP四次挥手.png)

当 Client 的数据发送完毕，之后再也没有数据发送之后，就需要释放连接，整个过程如下：

1. Client 发送一个没有数据的报文给Server，其中 FIN=1， Sequence = u， 并且 Client 进入 **FIN_WAIT_1** 状态

2. Server 接收到断开连接的请求后，自己有可能还有数据没有传完，因此先发送一个回复报文给 Client， 其中 ACK = 1， Sequence = v， Acknowledgement number = u+1， 并且进入 **CLOSE_WAIT** 状态， 此时收到这次回复的 Client 进入 **FIN_WAIT_2** 状态

3. 当 Server 的数据传输完毕之后，再向 Client 回复一个断开连接请求，其中 FIN=1，ACK=1， Sequence = w， Acknowledgement number = u+1，并且进入 **LAST_ACK** 状态，至此 Client 和 Server 之间不再有数据传输

4. 当 Client 收到 FIN 的报文后，进入 **TIME_WAIT** 状态，然后返回一个报文给 Server， 其中 Acknowledgement number = w+1， Sequence = u+1。此时，Client 在 **TIME_WAIT** 状态等待 2**MSL** 之后进入 **CLOSED** 状态，Server 则在收到 Client 此次回复之后进入 **CLOSED** 状态。

至此，Client 和 Server 之前经历四次挥手成功断开连接。

**Q1.** 为什么 TIME_WAIT 状态要经过 2MSL（最大报文段生存时间）才能返回到 CLOSED 状态？

A1. 因为网络是不可靠的，有可能最后一个 ACK 会丢失，所以 TIME_WAIT 状态就是用来重发可能丢失的 ACK 报文。如果在等待的 2MSL 内又从 Server 收到了 FIN，那么 Client 会重发 ACK 并再次等待 2MSL。

2MSL 是指 2 倍的 MSL（Maximum Segment Lifetime）, 指一个片段在网络中最大的存活时间。 2MSL 就是一个发送和回复所需的最大时间。如果在 2MSL 期间 Client 没有再次收到 FIN， 那么Client就认为 ACK 已经被成功接收，并结束TCP连接。


### TCP 保证可靠的传输机制

TCP 保证可靠传输的主要机制有：校验和，序列号，确认应答，超时重传，连接管理，流量控制，拥塞控制。

#### 校验和

在数据传输的过程中，将发送的数据段都当做一个16位的整数。将这些整数加起来。并且进位与结果相加，最后取反得到校验和。

发送方：在发送数据之前计算检验和，并进行校验和的填充。

接收方：收到数据后，对数据以同样的方式进行计算，求出校验和，与发送方的进行比对。

#### 确认应答与序列号

TCP 传输时对每个字节都进行编号，这就是序列号。TCP 传输过程中，接收方收到数据之后，都会对发送方进行确认应答，也就是 ACK=1 的报文，此报文中带有确认序号（Acknowledgement number）就是告诉发送方收到的是哪些数据，下一次发送从哪里开始发。

有了序列号之后，不仅可以用作应答，还可以保证数据传输的顺序，并且去掉重复的序列号，这也是 TCP 可靠性传输的保证之一。

#### 超时重传

发送方有可能接收不到 ACK 报文，原因可能是：

 - 数据发生了丢包，接收方没有接收到
 - 接收方收到了数据，但是返回的 ACK 报文却因为网络原因丢包了

超时重传机制就是为了解决这个问题引出来的：发送方在发送完数据之后有一个等待时间，如果时间达到却没有收到 ACK 报文，那么会对刚才发送的数据重新发送。而这个等待时间是动态计算的（Linux 和 Windows 系统中，超时以 500ms 为一个单位进行控制。）

#### 连接管理

看前一节 TCP 连接管理。

#### 流量控制

见下

接收端在收到数据之后，对数据进行处理，如果发送方发送的速度太快，会导致接收端的接收缓冲区很快被填满。此时如果发送端继续发送数据，接下来的数据就会全部丢包，继而导致丢包的一系列连锁反应。

TCP 根据 **接收方** 处理数据的的能力来控制发送端发送数据的速度，这个机制就是**流量控制**

在 TCP 首部信息当中有一个 16 位的**窗口大小**（Window size），它表示接收端接收数据缓冲区的剩余空间大小。这个数字越大，表示接收端缓冲区的剩余空间越大，网络的吞吐量越大。接收端会在确认应答（发送 ACK）时把自己的即时窗口大小填入，发送方则根据 ACK 报文里的窗口大小值的改变而改变自己的发送速度。如果接收到窗口大小的值为0，那么发送方将停止发送数据。并定期的向接收端发送窗口探测数据段，让接收端把窗口大小告诉发送端。

#### 拥塞控制

见下

### 流量控制 vs. 拥塞控制

**MSS**： Maximun Segment Size， TCP 一次传输发送的最大数据段长度

**RTT**： Round-Trip Time， 往返时延，表示从发送端发送数据开始，到发送端收到来自接收端的确认总共经历的时延。

TCP 传输大块数据时，要进行数据分段，每个分段所能携带的最大数据就是 1 个 MSS，假设大块数据为 100 个 MSS，那么发送端发送数据的方式有如下两种：

1. 每次发送 1 个， 收到接收方的确认之后才发送下一个
2. 一口气发送 100 个，然后一切接收确认。

第一种一个 RTT 只能处理一个包，这样的传输效率太低。方式 2 则会存在两个问题，一个是接收方的接收缓存区未必能一次性接收这么多数据，另一个就是网络的带宽也不一定足够大，容易出现丢包。前一个问题的就是**流量控制（Flow control）**， TCP 采用的是**滑动窗口机制（Sliding window）**， 后一个问题就是**拥塞控制（Congestion control）**。**发送方的发送窗口或者说网络传输交互就取决于这两个问题的控制，谁控制的更严格，谁就占据了决定性因素**

#### 流量控制

TCP 使用端到端流量控制协议来避免发送方发送数据太快，以致 TCP 接收方不能可靠地接收和处理数据。TCP 的流量控制通过**滑动窗口**来实现

#### 拥塞控制

流量控制是端到端的交互，如果只是局域网内的两台设备交互，通过滑动窗口大概能控制的不差，但是实际的网络情况非常的复杂，发送方和接收方之间还有路由器和交换机，网络传输线路又十分复杂，这个时候就需要拥塞控制机制。

拥塞控制主要又四个算法： **慢启动、拥塞避免、快速重传和快速恢复**

**慢启动：**

拥塞窗口（Congestion Window， cwnd）是慢启动算法为 TCP 发送方新增的窗口，对应上文，发送端取拥塞窗口和滑动窗口的最小值作为发送上限，即谁严格谁起决定因素。

1. 建立连接开始，发送端不了解网络的情况，cwnd初始化比较小的值， RFC建议 2-4 个 MSS， 具体视 MSS 的大小而定。
2. 如果发送的包都被 ACK， 说明还未达到拥塞点，则增加 cwnd， RFC 建议是没收到 n 个 ACK， 则 cwnd 新增 n 个 MSS， 呈指数关系增长。

**拥塞避免：**

慢启动出了维护 cwnd，还维护了慢启动临界值 ssthresh， 一般设为 65535（2^16）字节。

当 $cwnd <= ssthresh$, 还是处于慢启动环节，一旦 $cwnd > ssthresh$ 开始进入拥塞避免。

RFC 建议拥塞避免环节，无论一个 RTT 可以收到多少个 ACK， 每一次确认都只新增 1 个 MSS，呈线性关系增长，避免快速的触碰到网络拥塞点。

**快速重传和快速恢复：**

进入拥塞避免之后，最终还是会碰到拥塞点，发送方此时迟迟得不到确认（也可能是因为延迟确认导致），发送端会等待一段时间，如果等待时间过后还得不到确认就发起重传，这个过程也就是上文所说的**超时重传**。从发出原始包到重传该包的时间叫 RTO（Retransmission TimeOut）

快速重传：只要发送端一连收到三个重复的 ACK 即可断定有分组丢失了，应该立即重传丢失的报文段而不用继续等待为改报文段设置的重传计时器的超时。

快速恢复：

1. 当发送方连续收到三个 ACK 时， 执行“乘法减小”， 把慢启动门限减半
2. 发送方认为现在网络可能没有发生拥塞，因此不执行慢启动算法，而是把 cwnd 值设置为慢启动门限减半之后的值，直接开始执行拥塞避免。

## TCP vs. UDP

||TCP|UDP|
|:---:|:---|:---|
|可靠性|可靠|不可靠|
|连接性|面向连接|面向无连接|
|报文|面向字节流：应用层和 TCP 交互一次一个数据块（大小不等）， TCP把这些数据块当作一连串无结构的字节流|面向报文：应用层交给UDP多长的报文，UDP就发送多长的报文，一次发送一个报文，因此应用层必须选择大小合适的报文。如果报文太长，IP层需要分片，会降低效率|
|效率|低|高|
|双工性|全双工：发送数据的同时也能够接收数据|一对一，一对多，多对一，多对多|
|流量控制|滑动窗口|无|
|拥塞控制|慢开始，拥塞避免，快速重传，快速恢复|无|
|传输速度|慢|快|
|应用场景|对效率要求低，对准确度要求高或者要求有连接的场景，比如SMTP， HTTP， FTP|对效率要求高，对准确度要求低的场景，比如DNS|
